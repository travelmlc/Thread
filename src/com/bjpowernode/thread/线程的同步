 * 线程的安全问题：
 *      1、多线程并发的条件下有共享的数据
 *      2、共享的数据存在修改操作
 *
 *  Synchronized后面的小括号中传递的这个“数据”必须是线程共享的数据，才能达到多线程排队
 *
 *  假设有t1,t2,t3,t4,t5，一共5个线程，只需要t1,t2,t3排队，t4,t5不需要排队，则括号里
 *  写t1,t2,t3共享的数据，而这个对象对于t4,t5不是共享的。
 *
 *  共享的对象，锁只有一把，多个线程需要排队，不共享的线程直接拿走自己的对象锁，不需要排队。
 *
 *  java中的三大变量：
 *      1、局部变量（栈中）
 *      2、静态变量（方法区）
 *      3、实例变量（堆中）
 *
 *  以上三大变量中：局部变量永远不会存在线程安全问题，因为局部变量不共享（一个线程一个栈）
 *  局部变量在栈中，永远不会共享。
 *  静态变量在方法区中，方法区只有一个
 *  实例变量在堆中，堆也只有一个
 *  堆和方法区都是多线程共享的，所以都会存在线程安全问题。
 *
 *  Synchronized出现在实例方法上，一定锁的是this，没有其他对象。
 *  这种方式不灵活，还有另一个缺点：synchronize出现在实例方法上，表示整个方法体都需要同步，可能会
 *  无故扩大同步的范围，导致程序的执行效率降低，所以这种方式不常用。

 synchronized出现在实例方法的优点：
    代码量减少，如果共享的是对象就是this，并且需要同步的代码块就是整个方法，建议使用这种方式

    对于局部变量，使用StringBuilder，因为局部变量不存在线程安全问题

    ArrayList是非线程安全的
    Vector是线程安全的
    HashMap HashSet是非线程安全的
    Hashtable是线程安全的

    synchronized的三种用法：
        1、同步代码块：灵活
        synchronize(线程共享对象){
            同步代码块；
        }

        2、在实例方法上使用synchronized:表示共享对象是一个this，并且同步代码块是整个方法体

        3、在静态方法上使用synchronized：表示类锁，类锁永远只有1把，就算创建了100个对象，类锁也只有1把

        对象锁：100个对象，100把锁
